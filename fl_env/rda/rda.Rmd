---
title: "Flirma RDA"
date: "2023-01-31"
output:
 rmarkdown::html_document:
    theme: cerulean
    toc: yes
    toc_float: yes
    highlight: haddock
    number_sections: true
editor_options: 
  chunk_output_type: console
---

# RDA prep

Going to follow [this tutorial](https://github.com/Tom-Jenkins/seascape_rda_tutorial/blob/master/4.Redundancy_analysis/4.redundancy_analysis.R)

Also helpful info [here](https://r.qcbs.ca/workshop10/book-en/redundancy-analysis.html)

Maybe even the best one [here](https://pmassicotte.github.io/stats-denmark-2019/07_rda.html#/)

## Libraries, working directory

```{r}
library("phyloseq")
library("microbiome")
library("dplyr")

setwd("~/nicfall@bu.edu - Google Drive/My Drive/Flirma/flirma_networks/fl_env/rda")
```

## Microbiome data

Using CLR-transformed 'raw', but cleaned data

```{r}
ps.clean1 <- readRDS("../../fl_16s/01.generate_asv_table/flpub.ps.lulu.trim.clean.rds")
ps.clean1

ps.clean <- subset_samples(ps.clean1,site!="UK3")

ps.sid1 <- subset_samples(ps.clean,spp=="ssid")
ps.rad1 <- subset_samples(ps.clean,spp=="srad")

ps.sid <- prune_taxa(taxa_sums(ps.sid1)>0,ps.sid1)
ps.sid #4740 taxa and 179 samples
ps.rad <- prune_taxa(taxa_sums(ps.rad1)>0,ps.rad1)
ps.rad #4361 taxa and 135 samples

##clr transform
ps.sid.clr <-  microbiome::transform(ps.sid,"clr")
ps.rad.clr <-  microbiome::transform(ps.rad,"clr")

##extract data from phyloseq object
##sequence tables are ready to go - env data needs lots of processing
seq.sid.clr <- data.frame(ps.sid.clr@otu_table)
seq.rad.clr <- data.frame(ps.rad.clr@otu_table)

sam.sid.clr <- data.frame(ps.sid.clr@sam_data)
sam.rad.clr <- data.frame(ps.rad.clr@sam_data)
```

## Environmental data

### Main metrics

```{r}
kd.sum <- read.csv("kd.for.rda.csv",row.names=1)
sst.sum <- read.csv("sst.for.rda.csv",row.names=1)
chla.sum <- read.csv("chla.for.rda.csv",row.names=1)

kd.sum$sz_year <- paste0(kd.sum$site_zone,"_",kd.sum$year)
sst.sum$sz_year <- paste0(sst.sum$site_zone,"_",sst.sum$year)
chla.sum$sz_year <- paste0(chla.sum$site_zone,"_",chla.sum$year)

env.sum1 <- merge(kd.sum,sst.sum,by="sz_year",all=T)
env.sum1$site_zone.x==env.sum1$site_zone.y
env.sum2 <- merge(env.sum1,chla.sum,by="sz_year",all=T)
env.sum2$site_zone.x==env.sum2$site_zone.y

##don't need this year
env.sum <- subset(env.sum2,year!="2019")
```

### Lat/lon, depth, damage

```{r}
env.sum.more <- env.sum %>% 
  mutate(lat=case_when(
    site_zone == "LK1-I" ~ 24.535409,
    site_zone == "LK1-O" ~ 24.495846,
    site_zone == "UK1-I" ~ 24.903837,
    site_zone == "UK1-O" ~ 24.89525,
    site_zone == "UK2-I" ~ 25.217965,
    site_zone == "UK2-O" ~ 25.201217),
    lon=case_when(
      site_zone == "LK1-I" ~ -81.622376,
      site_zone == "LK1-O" ~ -81.648539,
      site_zone == "UK1-I" ~ -80.609678,
      site_zone == "UK1-O" ~ -80.572613,
      site_zone == "UK2-I" ~ -80.276098,
      site_zone == "UK2-O" ~ -80.226867),
    depth_m=case_when(
      site_zone == "LK1-I" ~ 3.96,
      site_zone == "LK1-O" ~ 6.40,
      site_zone == "UK1-I" ~ 3.05,
      site_zone == "UK1-O" ~ 5.49,
      site_zone == "UK2-I" ~ 4.27,
      site_zone == "UK2-O" ~ 6.86),
    dmg=case_when(
      sz_year == "LK1-I_2017" ~ 1.57,
      sz_year == "LK1-O_2017" ~ 1.33,
      sz_year == "UK1-I_2017" ~ 1.67,
      sz_year == "UK1-O_2017" ~ 1.67,
      sz_year == "UK2-I_2017" ~ 1.33,
      sz_year == "UK2-O_2017" ~ 1.33,
      .default=1),
  )
```

## Merge sample data with env. data

### Radians

```{r}
##radians
sam.rad.clr$sz_year <- paste0(sam.rad.clr$site_zone,"_",sam.rad.clr$year)

sam.rad.env1 <- merge(sam.rad.clr,env.sum.more,by="sz_year")

sam.rad.env <- sam.rad.env1[!duplicated(as.list(sam.rad.env1))]

colnames(sam.rad.env)
#sam.rad.env$year.x==sam.rad.env$year.x.1

row.names(sam.rad.env) <- sam.rad.env$sample_num

sam.rad.ready <- sam.rad.env %>%
  select(-sz_year,-time,-sample_num,-site_zone.x,-full_site,-sample,-spp,-year.x.1,-lib_size_clean,-is.neg)
```

### Siderea

```{r}
sam.sid.clr$sz_year <- paste0(sam.sid.clr$site_zone,"_",sam.sid.clr$year)

sam.sid.env1 <- merge(sam.sid.clr,env.sum.more,by="sz_year")

sam.sid.env <- sam.sid.env1[!duplicated(as.list(sam.sid.env1))]

colnames(sam.sid.env)
#sam.sid.env$year.x==sam.sid.env$year.x.1

row.names(sam.sid.env) <- sam.sid.env$sample_num

sam.sid.ready <- sam.sid.env %>%
  select(-sz_year,-time,-sample_num,-site_zone.x,-full_site,-sample,-spp,-year.x.1,-lib_size_clean,-is.neg)

##saving
#saveRDS(seq.rad.clr,file="seq.rad.clr.rds")
#saveRDS(seq.sid.clr,file="seq.sid.clr.rds")

#write.csv(sam.rad.ready,file="sample.data.rda.rad.all.csv")
#write.csv(sam.sid.ready,file="sample.data.rda.sid.all.csv")
```

# Analysis time - can start here

## Setup

```{r}
library("vegan")
library("dplyr")

#maybe:
#install.packages("adespatial")
#library("adespatial")

setwd("~/nicfall@bu.edu - Google Drive/My Drive/Flirma/flirma_networks/fl_env/rda")

seq.rad.clr <- readRDS("seq.rad.clr.rds")
seq.sid.clr <- readRDS("seq.sid.clr.rds")

sam.rad.ready <- read.csv("sample.data.rda.rad.all.csv",row.names=1)
sam.sid.ready <- read.csv("sample.data.rda.sid.all.csv",row.names=1)
```

## Check for colinearity

### Radians

```{r}
heatmap(abs(cor(sam.rad.ready[,(6:18)])), 
        # Compute pearson correlation (note they are absolute values)
        col = rev(heat.colors(6)), 
        Colv = NA, Rowv = NA)

abs.cor.rad <- abs(cor(sam.rad.ready[,(6:18)]))
##round 2 notes: [mean monthly data instead of annual data]
#all kd variables correlate, plus chla variables
#max sst correlates with mean, which leaves mean & min sst
#min sst correlates with depth 
#lon & lat are too close - keeping lon 

##round 1 notes:
#chla is near perfect match with turbidity
#lon & lat are too close - keeping lon 
#depth & mean.kd match - keeping depth

##run this one
env.rad.go  <- sam.rad.ready %>%
  select(-max.kd,-mean.kd,-mean.chla,-min.chla,-max.chla,-lat,-max.sst,-min.sst,-site,-zone,-season,-seq_run,-year.x)
##maybe I took away too many variables?
env.rad.go  <- sam.rad.ready %>%
  select(-site,-zone,-season,-seq_run,-year.x)

abs(cor(env.rad.go))

heatmap(abs(cor(env.rad.go)))
```

### Siderea

Shouldn't be different? Checking

```{r}
heatmap(abs(cor(sam.sid.ready[,(6:18)])), 
        # Compute pearson correlation (note they are absolute values)
        col = rev(heat.colors(6)), 
        Colv = NA, Rowv = NA)

abs.cor.sid <- abs(cor(sam.sid.ready[,(6:18)]))

env.sid.go  <- sam.sid.ready %>%
  select(-max.kd,-mean.kd,-mean.chla,-min.chla,-max.chla,-lat,-max.sst,-min.sst)

abs(cor(env.sid.go[,(6:10)]))

heatmap(abs(cor(env.sid.go[,(6:10)])))
```

## Normalize environmental data

```{r}
##radians
env.rad.go <- decostand(env.rad.go, method = "standardize")

str(env.rad.go)

#env.rad.go[,1:5] <- lapply(env.rad.go[,1:5], as.factor)
#str(env.rad.go)

##siderea
env.sid.go[,6:10] <- decostand(env.sid.go[,6:10], method = "standardize")

str(env.sid.go)

#env.sid.go[,1:5] <- lapply(env.sid.go[,1:5], as.factor)
#str(env.sid.go)
```

## RDA!

### Radians

```{r}
all.rda.rad <- rda(seq.rad.clr ~ ., data = env.rad.go)
summary(all.rda.rad)
RsquareAdj(all.rda.rad)

#all.rda.rad
sqrt(vif.cca(all.rda.rad)) #>2 indicates high collinearity

##forward selection
fwd.sel.rad <- ordiR2step(rda(seq.rad.clr ~ 1, data = env.rad.go), # lower model limit (simple!)
               scope = formula(all.rda.rad), # upper model limit (the "full" model)
               direction = "forward",
               R2scope = TRUE, # can't surpass the "full" model's R2
               #pstep = 1000, # not sure what this one is
               trace = TRUE) # change to TRUE to see the selection process

fwd.sel.rad$call

# Write our new model
#sig.rda.rad <- rda(seq.rad.clr ~ site + year.x + zone + lon + depth_m, data = env.rad.go)
sig.rda.rad <- rda(formula = seq.rad.clr ~ max.sst + depth_m + mean.sst + dmg + min.sst, data = env.rad.go)

# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(sig.rda.rad)
# $r.squared
# [1] 0.06706961
# 
# $adj.r.squared
# [1] 0.03090951

anova.cca(sig.rda.rad, step = 1000, by = "term")
anova.cca(sig.rda.rad, by = "axis")
anova.cca(sig.rda.rad)

plot(sig.rda.rad)

sqrt(vif.cca(sig.rda.rad)) #all less than 2

sig.rda.rad$CA$eig[sig.rda.rad$CA$eig > mean(sig.rda.rad$CA$eig)]

```

### Siderea

```{r}
all.rda.sid <- rda(seq.sid.clr ~ ., data = env.sid.go)

RsquareAdj(all.rda.sid)
# $r.squared
# [1] 0.1027679
# 
# $adj.r.squared
# [1] 0.03285368

##forward selection
fwd.sel.sid <- ordiR2step(rda(seq.sid.clr ~ 1, data = env.sid.go), # lower model limit (simple!)
               scope = formula(all.rda.sid), # upper model limit (the "full" model)
               direction = "forward",
               R2scope = TRUE, # can't surpass the "full" model's R2
               #pstep = 1000, # not sure what this one is
               trace = TRUE) # change to TRUE to see the selection process

fwd.sel.sid$call

# Write our new model
sig.rda.sid <- rda(seq.sid.clr ~ depth_m + year.x + site + mean.sst + 
    lon, data = env.sid.go)

# check the adjusted R2 (corrected for the number of
# explanatory variables)
RsquareAdj(sig.rda.sid)

anova.cca(sig.rda.sid, step = 1000, by = "term")

```

## Plotting results

```{r}
plot(sig.rda.rad,scaling=2,type="n")
points(sig.rda.rad,"sp",col="darkgreen",pch=19)
#text(sig.rda.rad,display="site",cex=.6)
text(sig.rda.rad,display="cn",cex=.8,col="blue")

plot(sig.rda.sid,scaling=2,type="n")
points(sig.rda.sid,"sp",col="darkgreen",pch=19)
#text(sig.rda.sid,display="site",cex=.6)
text(sig.rda.sid,display="cn",cex=.8,col="blue")
```

## Partial RDA

```{r}
colnames(env.rad.go)

rda.part.rad.all <- rda(seq.rad.clr ~ site*zone+year.x+mean.sst+min.sst+max.sst+depth_m+dmg+  # these are the effects we are interested in
                       Condition(season+lon), # these are the covariates
                       data = env.rad.go)

RsquareAdj(rda.part.rad.all)

fwd.sel.rad <- ordiR2step(rda(seq.rad.clr ~ 1, data = env.rad.go), # lower model limit (simple!)
               scope = formula(rda.part.rad.all), # upper model limit (the "full" model)
               direction = "forward",
               R2scope = TRUE, # can't surpass the "full" model's R2
               #pstep = 1000, # not sure what this one is
               trace = TRUE) # change to TRUE to see the selection process

fwd.sel.rad$call


```

